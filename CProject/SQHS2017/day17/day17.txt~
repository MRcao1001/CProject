				day17  Note
IP: 192.168.1.101

复习：
1. 联合体
	内存分配
		
	成员访问问题

2. 枚举类型
	直接使用
	枚举类型的成员都是整型常量或者字符常量

3. 数组 & 结构 作为函数参数
	数组作为函数参数自动转化为同类型指针
		
	结构：
		传递结构成员
		传递整个结构
		传递结构指针

4. 结构指针到链表
	malloc()/free() 成对出现
	malloc 得到的空间需要强制转化为所需类型
		进行判空处理
	
	free 只是释放指针所对应的内存，但指针仍然存在
		
	头插法 & 尾插法
	遍历链表
	有头链表
	
作业：
1. 销毁链表
	即释放所有 malloc 得到的空间

2. 在链表的指定位置插入元素

==================================================
1. 链表
（1）引入
	 线性表，非顺序，非连续
	 
	 malloc() 申请得到的空间
	 	遍历内存找到合适大小的空间
	 	然后返回其首地址，以供使用

（2）链表 & 数组
	 数组：
	 	存储数据单一
	 	顺序存储
	 	存在于栈区，随着程序运行可能会导致
	 	没有足够的空间分配给数组
	 
	 链表：
	 	链表是由一个个节点组成，这些节点在内存
	 	中随机分布

（3）节点（结点）
	a. 节点的组成
		数据域：保存基本数据
		指针域：保存的是下一个节点的地址

	b. 指针域问题
		指针指向问题：
			所谓指向某个地址或节点，就是保存
			该地址或保存该节点的地址

		注意区分当前节点和下一节点的表示：
			当前节点：p
			下一节点：p->pNext

	c. 链表的形成
		链表标识：
					头节点(有头链表)
		          	头指针(无头链表)

		头节点：
			数据域：不需要关心
			指针域：保存第一个节点的地址


		通过指针域将所有节点穿起来的形成一条链

（4）节点的一般形式
	 
	 struct 结构名
	 {
	 	//数据域
	 	//指针域
	 };

（5）有头链表的使用
	a. 创建头节点（唯一标识一条链表，便于后续操作）
	   所有的节点都是通过指针域相互关联
	   最终与头节点关联
	   
	b. 创建节点
		malloc() 注意类型转化
		初始化指针域（一般置为 NULL）
		
	c. 初始化数据域
		通过标准输入获得数据
		
	d. 形成链表
		将新的节点添加到头节点上
		
（6）有头链表的
		增：头插法/尾插法/任意位置插入
		删：头删法/尾删法/任意位置删除
		改：修改指定节点中的某一个信息
			或者全部信息
		查：查找指定节点，并输出该节点
			的相关信息

		遍历：输出全部节点的信息

2. 无头链表
	无头链表的第一个节点即为有效节点
	即其数据域和指针域均为有效值
	
	而有头链表的头节点，只用了指针域
	来保存第一个节点的地址，数据域未用

	标识链表：
		有头链表：头节点
		无头链表：头指针

3. 出栈函数：void mypop();
   入栈函数：void mypush(int c);
   错误处理：
   		空栈
   		满栈













































