		day04  Note
复习：		
1. 算术运算符
	= - * / 
	%:整数	
			
	++
		++i
		i++
	--
		a--
		--a
				
2. 关系运算符
	<   <=
	>	>=
	==  !=
	
	比较常量和变量是否相等：
		varialbe == value;
		value == variable;	//建议采取
	     
	结果：0（假） & 1（真）    

3. sizeof
	int a ;
		sizeof(a);
		sizeof a;	

===============================================
1. 运算符分类
	算术运算符
	关系运算符
	sizeof
	
	逻辑运算符
	位运算符
	赋值运算符
	条件运算符
	逗号运算符

2. 逻辑运算符
（1）逻辑与：&&
		表达式1 && 表达式2;
	结果：
		表达式1 和 表达式2 同时成立，
		则逻辑表达式的结果为真，否则为假	
		
	注：
		表达式1 为假，则逻辑表达式的值为 0（假）
		表达式2 不计算！		
	
	非零为真！
		
（2）逻辑或：||
		表达式1 || 表达式2;
	结果：
		表达式1 和 表达式2 只要有一个为真，
		则逻辑表达式的结果为真！
	注：
		表达式1 为真，则表达式2 不计算，
		逻辑表达式结果为真！！
		
		表达式1 为假，则计算表达式2！

（3）逻辑非：!
	 !表达式
	 
	 结果：
	 	若表达式为真，则结果为假
	 	  表达式为假，则结果为真！

3. 条件运算符
	？：
	使用形式：
		表达式1 ？ 表达式2 ： 表达式3;
		
	如果表达式1 成立，则取表达式2 的值为最终结果，
	否则取 表达式3 的值为最终结果！
	
	练习：
		a. 任意输入两个数，取两数中的最大值！
				a>b ? a : b;
		b. 任意输入三个数，取三数中的最大值！
			a<b ? (b>c ? b : c) : (a>c ? a : c);

4. 逗号运算符：，
	表达式1,表达式2,表达式3, ... 

	取最后一个表达式作为逗号表达式的值！
	
	若最后一个表达式和之前的表达式没有任何关系
	则之前表达式可以不用计算
	
	int a = 3,4,5,6;		//Error
	说明 赋值运算符的优先级 高于 逗号运算符


	int ret = (a>=b) ? a : b ;
	printf("%d\n", ret);
	printf("%d\n", (a>=b) ? a : b);

5. 位运算
（0）位运算只针对于整数和字符
     先把数据转化成二进制，然后进行位运算	
	
	二进制：0,1
	八进制：0～7
		以 0 开头的数，表示八进制数
	十进制：0～9
	十六进制：0～9,a~f(A~F)
		以 0x 开头的数，表示十六进制数
	
	十进制 <--> 二进制
		对 2 取余法：
		8 的二进制： 1000 
                商	  余数	
 			2 | 8  --  0
		    2 | 4  --  0   ^
		    2 | 2  --  0   |
		    2 | 1  --  1   |
	
		结果： 1000 
	2 --- > 10
		110101  = 1*2^0 + 0*2^1 + 1*2^2 + 0*2^3
		          1*2^4 + 1*2^5
				= 
				
			bit*2^n (n=0,1,2,3)

2^0 2^1 2^2 2^3 2^4 2^5 2^6 2^7 2^8 2^9 2^10		
  1   2   4   8  16  32  64 128 256 512 1024
	
	八进制 
			十进制 ---> 二进制 ---> 八进制
			二八进制转化
				000 ～ 111
	十六进制：
		二进制 <---> 十六进制
		
		0000(0) ～ 1111(15)
		
		二进制    十进制     八进制    十六进制 
		0000		  0		0(000)		0
		0001		  1		1(001)		1
		0010		  2		2(010)		2
		0011		  3		3(011)		3
		0100		  4		4(100)		4
		0101		  5		5(101)		5
		0110		  6		6(110)		6	
		0111		  7		7(111)		7
		1000		  8					8
		1001		  9					9
		1010		  10				a/A
		1011		  11				b/B
		1100		  12				c/C
		1101		  13				d/D
		1110		  14				e/E
		1111		  15				f/F	
	
	数据合法性：
		123		  	568
		0x123		0xea23
		110101      04567
		0xFFFF		0xFI123		//Error
		0876	(error)		124L
		346u			34f
		0XCBA
	
（1）位与：&
		5 & 7 = ？
		
		  0101 (5)
		& 0111 (7)
		----------
		  0101 (5)
	
	任何数与 0 相与 结果为 0
	任何数与 1 相与 结果为 自身
	
		保留某些位
		将某些位清零
		
（2）位或：|
		5 | 7 = ？
		  0101 (5)
		& 0111 (7)
		----------
		  0111 (7)		
		
	任何数与 1 相或结果为 1
	
	将某些位置 1
	
（3）位反：~
		~23：
		
		23: 0001 0111
	   ~23: 1110 1000(补码)	
	   --------------------	
	   		1110 0111(反码)
	   		1001 1000(原码)
		
		原码：
			正数的原码是它自身
			负数的原码是它正数的原码
			     其他位不变符号位为1
		反码：
			正数的反码是他自身
			负数的反码是自身原码符号位不变，
					其他位按位取反
		补码：
			正数的补码是自身
			负数的补码是自身反码加 1
		
		计算机存储：
			补码存储，原码输出！
		
		~1： 0000 0001
			 1000 0010 (-2)
		
		-1: 1000 0001（原码）
		    1111 1110（反码）
			1111 1111（补码）	
		
（4）异或：^
		5 ^ 8 = ?
		
		 0101
		^1000
		-----
		 1101
		
	对应位相同则为 0
	不同则为 1		
		
（5）左移：<<
	  5 << 2 = 20
	  	0000 010100
	  7 << 2 = 
	  	0000 011100 = 28
	
	左移 N 位，高位舍去，低位补 0
	相当于：
		 value * 2^N
	
（6）右移：>>
		相当于 value / (2^N)

6. 赋值运算符
（1）赋值：=
	 左值：只能是变量，表达式不能作为左值
	 右值：所有的左值都可作为右值
	 	   变量，常量，表达式 ...
	 	
	 	66 =  a;
	 	66 == a;
	 	   
（2）复合赋值运算符：
	 +=  -=  *=  /=  %=	 
	 
	 	a += 3;
	 相当于：
	 	a = a + 3;	
	 	
	 	a++;
	 	a = a + 1;

（3）位复合赋值
	 &=  |=  ~=  >>=  <<=  
	 
	 a &= 3;
	 a = a & 3;

	 a <<= 2;
	 a = a << 2;

7. 综合应用
	[0,31]

	123 = 0111 1011
	123 & x
		将第五位置 0，保留其他位，
方法一：		
	7654 3210
	0111 1011
   &1101 1111 ---> 223
	
	256 = 1 0000 0000
	0 1111 1111
	255-32

	int a = 123;
	a &= 223;	// a = a & 223;
方法二：
	a &= ~(0x01<<5)

	7654 3210
	0111 1011
	
	0000 0001 << 5  ---->  0010 0000
	~(0010 0000)    ---->  1101 1111
	
低四位置 1
	b |= 0x0f
		 



























































		
