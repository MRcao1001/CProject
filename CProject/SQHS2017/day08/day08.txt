		day08 Note 
IP: 192.168.155.7

复习：
1. 数组介绍
	用途
	定义
	
	数据结构：线性结构
	
	数组的特性：
		a. 元素类型一致
		b. 大小固定
		c. 在内存中连续分布
		
	int arr[5];
	//无论变量是输入，还是固定值，
	//或者用 const 修饰，均不可作为数组的大小
	int n = 5;	
	int buf[n];	//Error

2. 数组的初始化 & 访问
	int arr[5] = {0};
	int buf[6] = {[3]=7};
	int iBuf[] = {2,6,1,5};
	
	int iArr[];	//error

	通过下标逐个访问
	循环遍历访问每个元素或某一个元素

3. 随机数组
	#include<stdlib.h>
	#include<time.h>
	
	srand(time(0)); 	//srand(time(NULL));
	
	rand() % N;			//取 N 以内的随机数

作业：
1. 输入一个数，并判断数组中是否存在该数
   若存在则输出其下标，不存在则输出不存在
		循环遍历数组，找到该数即可

2. 倒置一个数组
		LEN/2  或者 LEN>>1
	
3. 该题为有序数组（定义时，直接初始化） 
   输入一个数，并判断数组中是否存在该数;
   若存在，则删除该数，并输出数组;
   若不存在，则插入数组中，插入后数组仍为有序。

	元素的前移和后移

================================================
1. 数组的初始化
	变量的初始化：
		int a = 0;	//OK
		
		int a;
		a = 0;	//OK

		int b;
		b = a;

	数组的初始化
		int arr[5] = {0};
		
		int buf[5];
		//Error,buf[5] 是数组中的具体的一个元素
		buf[5] = {1,2,3,4,5};	
		
		buf[0], buf[1]
		
		//Error, buf 是个常量
		buf = {1,2,3,4,5};

		buf[5] = arr[5]; 	//表达式是 OK
		buf = arr;			//Error

	数组只能定义的同时初始化！！！！
	
2. 数组的大小问题：
	数组大小 = sizeof(arr[0])*LEN

	每一个元素的字节数：
		sizeof(arr)/LEN

3. 排序 --- 冒泡排序	
	int arr[5] = {12,45,23,66,5};
	
（1）原理分析 --- 每轮比较，得出当前轮的最值

		参与比较的元素		记录最值
第一轮： 
		arr[0]  arr[1] ---> arr[1](45)
		arr[1]  arr[2] ---> arr[2](45)
		arr[2]  arr[3] ---> arr[3](66)
		arr[3]  arr[4] ---> arr[4](66)
	
	    第一个最值：arr[4](66) （4次）
	    比较结果：12  23  45  5  66

第二轮：	
		arr[0]  arr[1] ---> arr[1](23)	
		arr[1]  arr[2] ---> arr[2](45)
		arr[2]  arr[3] ---> arr[3](45)
		
		第二个最值：arr[3](45)  （3次）
		比较结果：12  23  5  45  66

第三轮： 
		arr[0]  arr[1] ---> arr[1](23)
		arr[1]  arr[2] ---> arr[2](23)
		
		第三个最值：arr[2](23)  （2次）
		比较结果：12  5  23  45  66

第四轮： 
		arr[0]  arr[1] ---> arr[1](12)
		
		第四个最值：arr[1](12)	（1次）
		比较结果：5  12  23  45  66

（2）代码实现
	结果分析：
	 比较的轮数 = 数组元素的个数-1
	 每轮比较的次数 = 元素个数 - 轮数

	因此需要两重循环：
		外层循环控制比较的轮数
		内层循环控制比较的次数，即控制元素的比较

5. 一维数组的地址问题
	int arr[5] = {0};
	
	arr:数组名，标识了数组，同时代表数组的首地址
	&arr[0]:数组首元素的地址
	&arr:代表整个数组的地址

		  arr = 0x7ffdffe0b6f0
	  &arr[0] = 0x7ffdffe0b6f0
	     &arr = 0x7ffdffe0b6f0

		arr+1 = 0x7ffdffe0b6f4
	&arr[0]+1 = 0x7ffdffe0b6f4
	   &arr+1 = 0x7ffdffe0b704

	  &arr[1] = 0x7ffdffe0b6f4
	  &arr[2] = 0x7ffdffe0b6f8
	  &arr[3] = 0x7ffdffe0b6fc
	  &arr[4] = 0x7ffdffe0b700

6. 再看数组元素的访问
	*:间接运算符（取值运算符）
	
	通过数组名访问数组元素
	int arr[5];
	
	*arr     ---> arr[0]
	*(arr+1) ---> arr[1]
	*(arr+2) ---> arr[2]
	*(arr+3) ---> arr[3]
	*(arr+4) ---> arr[4]

作业:
	数组小孩圈：
        假设有 100 个小孩按序排好，参与游戏，
        指定从第 i 个小孩开始数数，数到
        iNum 时，该小孩淘汰，以此类推，直到
        剩余一个小孩为止。












